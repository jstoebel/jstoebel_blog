---
layout: post
title: Two Tails of Git Woe
date: '2016-03-23T00:38:18+00:00'
permalink: two-tails-of-git-woe
---
Tonight I bring you two tails of Git Woe. Git has a reputation of being difficult, but I actually think that isn't true. Git is a pretty easy program to learn, but at its heart it is a collaboration tool for working with other people across time and space. And _that_ is a very difficult proposition. Maybe we are asking a bit much of Git to some how make collaboration an easy and brainless process.

## Tail One: Many Branches or One?

Our group has been working together on a Q&A forum. For the past two weeks we have been working on our individual features on separate branches (some of us were on entirely different forks, but details details...). The point is that we chose to work separately and then merge our changes together once we were all done. I think the initial plan was to use different branches so as to not have our initial work mess with each other. We thought it would be a simple matter of merging all of our work back together. This is predicated by the assumption that our contributions are entirely separate, which turned out to not be entirely true. Some people's features had to be inserted into the files generated by other team mates. Some files (like model files) were touched by more than one team mate. This meant that we had to be extra careful when doing our merge. Person A merged their changes in, person B pull down the changes, then merges their changes back in, repeat. Conflicts had to be resolved. Some work was lost in the process. The whole process could have been much worse if we had more work, but it wasn't as smooth as expected.

The morale: When you're working on similar areas of the codebase, don't pretend that you can "not get in each other's way". Make it a point to get in each other's way early and often.  That way you can resolve the conflicts early on rather than punt them all to the end.

## Tail 2: Pull before you push!

It was something I had been told before many times, but I have now officially learned it the hard way. I was feeling really proud of myself for tackling an issue on the CodeWorkout repo. I pushed all of my changes to my repo and then did a new pull request. At the top of the next screen I was warned fair and square that my changes would not be able to automatically merged. Did I heed them? No! I just pushed them on through. I was pushing out of date code and was asking the maintainers of CodeWorkout to merge my new contributions, my old version of _their_ code and the up to date version of their code. Oops! Fortunately its not hard to withdraw a pull request. I pulled down their master branch into my branch, found and resolved the conflict ([this resource][1] was helpful in doing that) and then did a new PR. 

The morale: Always make sure you are up to date before you do a push. Ideally, keep an eye on the upstream repo, pull in new changes and resolve conflicts as soon as them come. Don't get to far behind, because when you are ready to push and it is inevitably late and past your bed time you will need to resolve a bunch of conflicts before you can push your work back.


  [1]: http://genomewiki.ucsc.edu/index.php/Resolving_merge_conflicts_in_Git
